# 向量

2020-05-14⭐
@author Jiawei Mao
****

## 简介

向量是一维数据，类似于数学上集合的概念，由 1 个或多个元素组成，可以存储数值型、字符型和逻辑型数据，但必须是 **相同类型数据**。R 中，单个数值没有单独的数据类型，而是作为向量的一种特例。

在R中，向量的大小在创建时已经确定，因此如果要添加或删除元素，需要重新给向量赋值。

R 支持 6 种基本类型的原子向量：

- double
- integer
- character
- logical
- complex
- raw

## 向量类型

### double

double 向量存储数字。R 将你输入的任何数字保存为 double。例如：

```R
> die <- c(1,2,3,4,5,6)
> die
[1] 1 2 3 4 5 6
> typeof(die)
[1] "double"
```

有些 R 函数将 double 称为 numerics，两者等价。

### integer

integer 向量存储整数。在数据分析中 integer 类型使用较少，因为整数可以保存为 double 对象。

显式创建 integer 向量：

```R
> int <- c(-1L, 2L, 4L)
> int
[1] -1  2  4
> typeof(int)
[1] "integer"
```

必须在数字后加 `L`，才会保存为 integer。

### character

character 向量存储文本。字符串用双引号 "" 括起来。示例：

```R
> text <- c("Hello", "World")
> text
[1] "Hello" "World"
> typeof(text)
[1] "character"
> typeof("Hello")
[1] "character"
```

### logical

logical 向量存储 TRUE 和 FALSE，也可以用简写 T 和 F。

```R
> logic <- c(TRUE, FALSE, TRUE)
> logic
[1]  TRUE FALSE  TRUE
> typeof(logic)
[1] "logical"
> typeof(F)
[1] "logical"
```

### Complex and raw

double, integer, character 和 logical 是 R 中最常见的原子向量类型。但 R 还支持另外两种类型：complex 和 raw。

complex 向量存储复数：

```R
> comp <- c(1 + 1i, 1 + 2i, 1 + 3i)
> comp
[1] 1+1i 1+2i 1+3i
> typeof(comp)
[1] "complex"
```

raw 向量存储字节。生成 raw 向量很复杂，但是可以用 `raw(n)` 创建长度为 n 的空向量。

```R
> raw(3)
[1] 00 00 00
> typeof(raw(3))
[1] "raw"
```



### 数值向量

向量是将若干个相同基础类型的值存储在一起，各个元素可以按序号访问。如果将若干个数值存储在一起可以用序号访问，就叫**数值型向量**。

用 `c()` 将多个元素或向量合成一个向量。如：

```r
> a <- c(10, 6, 4, 7, 8)
> a
[1] 10  6  4  7  8
> b <- c(1:3, 10:13)
> b
[1]  1  2  3 10 11 12 13
> x1 <- c(1, 2)
> x2 <- c(3, 4)
> x <- c(x1, x2)
> x
[1] 1 2 3 4
```

`1:3` 这样的写法表示从 1 到 3 的整数组成的向量。

`length(x)` 可以求x的长度。长度为零的向量表示为 `numeric(0)`。 `numeric()` 函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量，如 `numeric(10)` 会生成元素为10个零的向量。

数值型向量支持 sum, mean, var, sd, min, max 等运算。

### 字符向量

| 函数     | 功能       |
| -------- | ---------- |
| toupper  | 转为大写   |
| tolower  | 转为小写   |
| nchar    | 字符串长度 |
| strsplit | 拆分字符串 |
| gsub     | 替换字符   |

### 逻辑向量

| 函数  | 功能           |
| ----- | -------------- |
| which | 筛选数据下标   |
| all   | 是否全部为TRUE |
| any   | 是否含有TRUE   |

```r
# 包含 8 个元素的数值向量
> vector <- c(10, 40, 78, 64, 53, 62, 69, 70)
# 选出 (60,70) 内的元素并输出
> print(vector[which(vector > 60 & vector < 70)])
[1] 64 62 69
> all(c(TRUE, TRUE, FALSE))
[1] FALSE
> any(c(TRUE, FALSE, FALSE))
[1] TRUE
```

逻辑值只有 `TRUE` 和 `FALSE`，缺失值为 `NA`。

将对应位置为 `TRUE` 的元素选择出来。例如：

```r
> x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
[1] 1.1 3.3 5.5
> x
[1] 1.1 2.2 3.3 4.4 5.5
```

这种方式，依然是返回一个新的向量。

逻辑计算：

- 向量与标量的计算，向量的每个元素与标量一次计算
- 等长向量的运算，对应元素依次运算
- 与 NA 比较生成 NA

```r
[1] TRUE
> c(1, 3, 5) > 2
[1] FALSE  TRUE  TRUE
> (1: 4) >= (4:1)
[1] FALSE FALSE  TRUE  TRUE
> c(1, NA, 3) > 2
[1] FALSE    NA  TRUE
> NA == NA
[1] NA
```

逻辑选择：

```r
> x <- c(1, 4, 6)
> x[x>3]
[1] 4 6
```

通过 `is.na()` 函数判断是否为 NA:

```r
> is.na(c(1, NA, 3) > 2)
[1] FALSE  TRUE FALSE
```

用 `is.finite()` 判断是否为 inf 值：

#### which

`which()` 可以用来找到满足条件的下标，例如：

```r
> x <- c(3, 4, 3, 5, 7, 5, 9)
> which(x > 5)
[1] 5 7
> seq(along=x)[x>5]
[1] 5 7
```

`seq(along=x)` 生成由 x 的下标组成的向量。

`which.min()`, `which.max()` 可用来计算最小值和最大值的下标，不唯一时只取第一个。例如：

```r
> x <- c(3, 4, 3, 5, 7, 5, 9)
> which.min(x)
[1] 1
> which.max(x)
[1] 7
```



## 创建向量

- 使用 `c()` 函数（表示连接，Concatenate）创建向量

```r
> apple <- c("red", "green", "yellow")
> apple
[1] "red"    "green"  "yellow"
> class(apple)
[1] "character"
```

- 数值向量

```r
> die <- c(1,2,3,4,5,6)
> die
[1] 1 2 3 4 5 6
> is.vector(die)
[1] TRUE
> class(die)
[1] "numeric"
```

> [!TIP]
>
> `is.vector` 测试一个对象是否为原子向量。

- 单值向量

```R
> five <- 5
> is.vector(five)
[1] TRUE
> length(five)
[1] 1
```

> [!TIP]
>
> `length()` 返回向量长度。

范围：

```r
> x <- c(1:3, 10:13)
> x
[1]  1  2  3 10 11 12 13
```

多类型，自动转换为字符串：

```r
> v <- c('Z', 1, TRUE)
> v
[1] "Z"    "1"    "TRUE"
> class(v)
[1] "character"
```

### 创建时指定大小

```r
y <- vector(length = 2)
```

### 向量长度

使用 `length()` 获取向量长度：

```r
> x <- c(1)
> length(x)
[1] 1
> x <- c(1, 2, 3)
> length(x)
[1] 3
```

### seq

`seq` 是冒号运算符的推广，用于生成规则数列。

- `seq` 是标准的泛型方法。
- `seq.int` 针对基础类型，速度更快，限制更多。
- `seq_along` 和 `seq_len`

语法：

```r
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)

seq.int(from, to, by, length.out, along.with, ...)

seq_along(along.with)
seq_len(length.out)
```

说明：

- `from` 起始值，默认为 1, inclusive
- `to` 终止值, inclusive
- `by` 差值
- `length.out` 生成的序列长度。
- `along.with` 从该参数序列获得序列长度

另外：

- `seq(6)` 等价于 `1:6`
- `seq(2, 5)` 等价于 `2:5`

```r
> seq(5)
[1] 1 2 3 4 5
> 1:5
[1] 1 2 3 4 5
> seq(2:5)
[1] 1 2 3 4
> 2:5
[1] 2 3 4 5
> seq(11, 15, by=2)
[1] 11 13 15
> seq(0, 2*pi, length.out = 100) # 生成 0 到 2pi 的等差序列，序列长度为100
```

## 元素命名

向量可以为每个元素命名。

```r
ages <- c('LiLei'=30, 'HanMeimei'=25, 'ErShazi'=18)
```

或：

```r
> ages <- c(30, 25, 18)
> names(ages) <- c('LiLie', 'HanMeimei', 'ErShazi')
> ages
    LiLie HanMeimei   ErShazi
       30        25        18
```

或：

```r
> ages <- setNames(c(30, 25, 28), c("LiLei", "HanMeimei", "ErShazi"))
> ages
    LiLei HanMeimei   ErShazi
       30        25        28
```

设置好元素名称后，可以使用元素名称选择元素：

```r
> y <- c("a" =  11, "b" =  12, "c" =  13, "d" =  14)
> y
 a  b  c  d
11 12 13 14
> y[c("d", "a")]
 d  a
14 11
```

返回的元素顺序依然是按照提供的索引顺序。

用 `unname(x)` 返回去掉元素名的 x 的副本。

用 `names(x) <- NULL` 去掉 x 元素名。

## 索引

R 索引编号从 1 开始。

说明：

- `x[i]` 选择第 `i` 个元素，如 `x[2]` 取第二个元素
- `x[c(a, b)]` 选择第 `a`, `b` 两个元素，如 `x[c(1,3)]` 取第1、3号元素
- `x[i] <- k` 将第 `i` 个元素修改为 `k`，如 `x[2] <- 99` 修改第二个元素为 99。
- `x[c(i, j)] <- c(m, n)` 将第 `i`, `j` 两个元素修改为 `m` 和 `n`
- `x[-i]` 返回一个移除第 `i` 个元素的向量
- `x[]` 取 x 得全部元素作为子集

### 单整数

```r
> a <- c(1, 2, 5, 3)
> a[3]
[1] 5
```

> R 的索引以 1 开始

使用 `x[1] <- 6` 语法可以修改第一个元素的值。即用于赋值。

```r
> x <- c(6, 6.25, 7.45)
> x[1]
[1] 6
> x[1] <- 6.15
> x
[1] 6.15 6.25 7.45
```

### 多整数

选择多个元素，如选择第1和5两个元素：

```r
> x <- c(1.1, 2.2, 3.3, 4.4, 5.5)
> x[c(3, 1)]
[1] 3.3 1.1
```

`[]` 中为向量，返回的元素按照提供索引的顺序返回。

修改值：

```r
> x
[1] 6.15 6.25 7.45
> x[c(1, 3)]
[1] 6.15 7.45
> x[c(1, 3)] <- c(6, 8)
> x
[1] 6.00 6.25 8.00
```

### 负整数-删除元素

提供负数索引删除元素。例如，删除第二个元素：

```r
> x <- c(1.1, 2.2, 3.3, 4.4, 5.5)
> x[-2]
[1] 1.1 3.3 4.4 5.5
> x
[1] 1.1 2.2 3.3 4.4 5.5
```

可以看到，原向量不变，而是生成一个新的向量。

删除多个元素：

```r
> x <- c(1, 2, 3)
> x[-c(1, 3)]
[1] 2
```

> 负整数下标不能于正整数下标同时用来从某一向量中取子集。

### 空下标

`x[]` 取 x 全部元素。例如：

```r
> x <- c(1, 2, 3)
> y <- x[] # y 和 x 元素完全相同
> y
[1] 1 2 3
> y[] <- 61 # 给 y 的每个元素依次赋值
> y
[1] 61 61 61
> x
[1] 1 2 3
> x <- 61 # 给 x 赋值
> x
[1] 61
```

### `x[0]`

`x[0]` 返回类型相同、长度为零的向量，如 `numeric(0)`。相当于空集。

当 0 与正整数或负整数下标一起使用时被忽略。

例如：

```r
> x <- c(1, 2, 3)
> y <- x[0]
> class(y)
[1] "numeric"
> length(y)
[1] 0
```

### 下标越界

如果使用越界下标，读取时返回缺失值，并不出错。

给超出下标元素赋值，则向量自动增长，中间没有赋值的元素为缺失值。

```r
> x
[1] 1.00 4.00 6.25
> x[5] <- 8
> x
[1] 1.00 4.00 6.25   NA 8.00
```

### 下标映射

使用下标从向量选择元素，可以使用重复下标。例如有 3 个礼品，编号为 1, 2, 3，价格分别为 68， 88， 168。假设某个收银员在一天内分别售出礼品编号为 3, 2, 1, 1, 2, 2, 3，可以用如下方式获得售出的这些礼品对应的价格：

```r

```

### 选择连续元素

```r
a_vector[2:4]
```

等价于 `a_vector[c(2, 3, 4)]`

### 逻辑下标

下标可以是与向量等长的逻辑表达式。例如：

```r
> x <- c(1, 4, 6.25)
> x[x>3]
[1] 4.00 6.25
```

如果逻辑下标中有缺失值，对应结果也是缺失值。所以，在用逻辑下标作子集选择时，要考虑缺失值问题。如使用 `!is.na` 去掉缺失值。例如：

```r
> x <- c(1, 4, 6.25, NA)
> x[x>2]
[1] 4.00 6.25   NA
> x[!is.na(x) & x > 2]
[1] 4.00 6.25
```

逻辑下标除了用来对向量取子集，还经常用来对数据框取子集，也用在向量化运算中。例如，对如下函数：

$$f(x)=\begin{cases}
  1, &x\geq0 \\
  0, &x<0
\end{cases}$$

定义函数：

```r
f <- function(x) {
  y <- numeric(length(x))
  y[x >= 0] <- 1
  y[x < 0] <- 0 # <U+591A><U+4F59>

  y
}
```

如果 x 是向量，还可以使用 `ifelse()` 函数实现相同的功能：

```r
y <- ifelse(x>=0, 1, 0)
```

## 向量运算

|运算|说明|
|---|---|
|`a*b`|向量a 和 b 各个元素依次相乘|
|`a+b`|向量各个元素依次相加|

### 标量和向量

R 没有单独的标量类型，标量实际上是长度为 1 的向量。

向量与标量运算，向量的每个元素依次与标量运算。即线性代数中的数乘。如：

```r
> x <- c(1, 5, 10)
> x+2
[1]  3  7 12
> x-2
[1] -1  3  8
> x*2
[1]  2 10 20
> x/2
[1] 0.5 2.5 5.0
> x^2
[1]   1  25 100
> 2/x
[1] 2.0 0.4 0.2
> 2^x
[1]    2   32 1024
```

如果向量中存在缺失值，计算后依旧缺失：

```r
> c(1, NA, 2) + 10
[1] 11 NA 12
```

### 等长向量与向量

等长向量的运算，为对应元素的两两运算，例如：

```r
> a <- c(1, 10)
> b <- c(4, 2)
> a+b
[1]  5 12
> a-b
[1] -3  8
> a*b
[1]  4 20
> a/b
[1] 0.25 5.00
```

### 不等长常量与向量

对不等长向量的数学运算，如果长度为倍数关系，则重复利用短的向量：

```r
> a <- c(10, 20)
> b <- c(1, 3, 5, 7)
> a+b
[1] 11 23 15 27
> a*b
[1]  10  60  50 140
```

如果两个向量长度不是倍数关系，会给出警告信息：

```r
> c(1, 2) + c(1, 2, 3)
[1] 2 4 4
Warning message:
In c(1, 2) + c(1, 2, 3) :
  longer object length is not a multiple of shorter object length
```

## 向量函数

### 向量化函数

R 中的函数一般都是向量化的，在R中，如果普通的一元函数以向量为自变量，一般会对每个元素依次计算。如 sqrt, log, log10, exp, sin, cos, tan 等。

例如常用的数学函数：

- 舍入：ceiling, floor, round, signif, trunc, zapsmall
- 符号函数 sign
- 绝对值 abs
- 平方根 sqrt
- 对数与指数函数 log, exp, log10, log2
- 三角函数 sin, cos, tan
- 反三角函数 asin, acos, atan, atan2
- 双曲函数 sinh, cosh, tanh
- 反双曲函数 asinh, acosh, atanh

如果自己编写的函数没有考虑向量化问题，可以用 `Vectorize()` 函数将其转换为向量化版本。

### 排序函数

- `sort(x)` 返回排序结果。
- `rev(x)` 将 `x` 的各元素的顺序反转
- `order(x)` 返回排序下标

例如：

```r
> x <- c(3, 5, 2)
> sort(x) # 返回排序后的结果
[1] 2 3 5
> rev(x) # 将 x 的元素顺序反转, (3, 5, 2) 转换为 (2, 5, 3)
[1] 2 5 3
> rev(sort(x)) # 实现降序排列
[1] 5 3 2
> order(x) # 返回各元素的位置，3 表示最小元素是第三个
[1] 3 1 2
> x[order(x)] # 等价于 sort(x)
[1] 2 3 5
```

